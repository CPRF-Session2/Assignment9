Amanda Cuevas
1) Malloc() and calloc() both allocate memory, however, malloc() is known for not initializing the allocated memory, while calloc() is known for zero-initializing the memory. Malloc() only takes one argument in its code, which is as follows: castType *malloc(size_t numBytes). However, because malloc() does not initialize, the programmer must use memset() to initialize instead. Meanwhile, calloc() takes two arguments, as seen in the following code: castType *calloc(size_t numElement, size_t size). Both return a pointer to allocated memory on success, or NULL on failure.
2) One can determine the size of an allocated portion of memory either statically or dynamically. If you allocate a portion of memory statically, the programmer must name the size of allocated memory that the variable or function  needs upon its declaration (Ex. int arr[15]). However, with dynamic memory allocation, the allocating takes place during the execution, and gives memory to the variable/function based on the programmer's request. The extra, unused memory is freed at the end. Dynamic memory allocation is done using malloc() or calloc() (refer to question one for more information).
3) In the heap, memory space is shared with all other programs, so if the memory space there isn't freed, it could affect other programs and also cause fragmentation. However, the stack has memory that is exclusively allocated to each program, therefore not causing intermingling issues with other programs, and making it so that you are not required to free memory on the stack.
4) One needs to test the return value from malloc because it is possible that malloc could not find anywhere to allocate memory, and would return NULL instead. By using an if statement to test if malloc is NULL or not, we could see if malloc passed or failed in its aforementioned attempt to allocate memory.
